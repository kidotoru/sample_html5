<!DOCTYPE html>
<html>
	<head>
		<title>Page05</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width">
		<style type="text/css">
			* {
				margin: 0 auto;
			}

			html,
			body {
				width: 100%;
				height: 100%;
				background-color:  black;
				color: white;
			}		
			
.button {
	display: inline-block;
	width: 120px;
	height: 54px;
	text-align: center;
	text-decoration: none;
	line-height: 54px;
	outline: none;
}
.button::before,
.button::after {
	position: absolute;
	z-index: -1;
	display: block;
	content: '';
}
.button,
.button::before,
.button::after {
	-webkit-box-sizing: border-box;
	-moz-box-sizing: border-box;
	box-sizing: border-box;
	-webkit-transition: all .3s;
	transition: all .3s;
}			

			.button {
				border: 1px solid #15aeec;
				background-color: #49c0f0;
				background-image: -webkit-linear-gradient(top, #49c0f0, #2cafe3);
				background-image: linear-gradient(to bottom, #49c0f0, #2cafe3);
				//border-radius: 4px;
				color: #fff;
				line-height: 50px;
				-webkit-transition: none;
				transition: none;
				text-shadow: 0 1px 1px rgba(0, 0, 0, .3);
			}
			.button:hover {
				border:1px solid #1090c3;
				background-color: #1ab0ec;
				background-image: -webkit-linear-gradient(top, #1ab0ec, #1a92c2);
				background-image: linear-gradient(to bottom, #1ab0ec, #1a92c2);
			}
			.button:active {
				background: #1a92c2;
				box-shadow: inset 0 3px 5px rgba(0, 0, 0, .2);
				color: #1679a1;
				text-shadow: 0 1px 1px rgba(255, 255, 255, .5);
			}			
			a {
				text-decoration: none;
			}
		</style>


	</head>
	<body>
		<p>
			<a id="create" class="button" href="#"> Create</a>
			<a id="interval" class="button" href="#">Interval</a>
			<a id="interval_stop" class="button" href="#">Interval Stop</a>
			<span id="progress">wait...</span>
		</p>
		<canvas id="loop" width="1024" height="512" style="background-color: black;width:  100%;"></canvas>

		<canvas id="detail" width="512" height="512" style="background-color: black;width:  100%;"></canvas>

		<script type="text/javascript" src="./js/libs/jquery/jquery.js"></script>
		<script>
			var gWorld;
			var tmpSize = 512;

			$(document).ready(function () {
				$('#interval_stop').hide();

				gWorld = new Terrein(tmpSize * 2, tmpSize);
				$('#create').mousedown(function (e) {
					$('#progress').text('wait.');

					create();
				});
				$('#interval').mousedown(function (e) {
					$('#interval_stop').show();
					$('#interval').hide();
create();
					intervalP = setInterval(create, 5000);
				});
				$('#interval_stop').mousedown(function (e) {
					$('#interval').show();
					$('#interval_stop').hide();

					clearInterval(intervalP);
				});

				$('#loop').mousemove(function (e) {
					var cx = e.offsetX;
					var cy = e.offsetY;
					var w = $('#loop').width();
					var h = $('#loop').height();
					var x = Math.floor(cx * 512 * 2 / w);
					var y = Math.floor(cy * 512 / h);


					$('#progress').text('x=' + x + ',y=' + y + ',h=' + gWorld.array[x][y]);

				});

				$('#loop').mousedown(function (e) {
					$('#progress').text('wait.');

					setTimeout(function () {

						var cx = e.offsetX;
						var cy = e.offsetY;
						var w = $('#loop').width();
						var h = $('#loop').height();
						var x = Math.floor(cx * 512 * 2 / w);
						var y = Math.floor(cy * 512 / h);

						x -= 512 / 4 / 2;
						y -= 512 / 4 / 2;

						// 画面端の場合の処理
						x < 0 ? x = 0 : x;
						y < 0 ? y = 0 : y;
						x + 128 > 512 * 2 ? x = 512 * 2 - 128 - 1 : x;
						y + 128 > 512 ? y = 512 - 128 - 1 : y;

						$('#progress').text('x=' + x + ',y=' + y);
						var tmpSize = 512;
						var cs = document.getElementById('detail');
						var ctx = cs.getContext('2d');
						/* パスを初期化 */
						ctx.beginPath();

						var t = new Terrein(tmpSize, tmpSize);

						var pmap;
						pmap = gWorld.array;

						t.iniSize = 512;
						for (i1 = 0, i2 = x; i1 < t.array.length; i1 += 4, i2++) {
							for (j1 = 0, j2 = y; j1 < t.array.length; j1 += 4, j2++) {
								// tl = 左上の値, tr = 右上の値, bl = 左下の値, br = 右下の値
								t.init(pmap[i2][j2], pmap[i2 + 1][j2], pmap[i2][j2 + 1], pmap[i2 + 1][j2 + 1], i1, j1, 4);
							}
						}


						// tl = 左上の値, tr = 右上の値, bl = 左下の値, br = 右下の値
						//t.init(pmap[x][y], pmap[x + mm][y], pmap[x][y + mm], pmap[x + mm][y + mm],0,0,4);
						t.render(ctx, 0);

						var cs2 = document.getElementById('loop');
						var ctx2 = cs2.getContext('2d');
						/* パスを初期化 */
						ctx2.beginPath();
						gWorld.render(ctx2, 0);
						ctx2.beginPath();

						ctx2.globalCompositeOperation = "lighter";
						ctx2.strokeStyle = "rgba(255,255,255,0.5)";

						ctx2.fillRect(x, y, 512 / 4, 512 / 4);

						ctx2.globalCompositeOperation = "source-over";

						ctx2.stroke();

					}, 0);


				});

//initial-scale=1.0

// the initial seed
//Math.seed = 6;
				create();


			});

			function create() {
				setTimeout(function () {

					Math.seed = +new Date();
					var cs = document.getElementById('loop');
					//var style = window.getComputedStyle(cs);
					//pxを削除する
					//cs.width = style.width.replace(/px/, "");
					//cs.height = style.height.replace(/px/, "");
					var ctx = cs.getContext('2d');
					/* パスを初期化 */
					ctx.beginPath();

					//gWorld = new Terrein(tmpSize * 2, tmpSize);
					// tl = 左上の値, tr = 右上の値, bl = 左下の値, br = 右下の値 , x ,y , size
					gWorld.init(0, 0, 0, 0, 0, 0, tmpSize);

					gWorld.init(0, 0, 0, 0, 512, 0, tmpSize);


					gWorld.render(ctx, 0);
					//gRight = new Terrein(tmpSize, tmpSize);
					//gRight.init(0, 0, 0, 0);
					//gRight.render(ctx, 512);
					$('#progress').text('done.');

				}, 0);

			}
			;


			function Terrein(width, height) {

				this.iniSize = 512;

				this.array = new Array();
				for (i = 0; i < width; i++) {

					// １次元配列の各番地に、配列を作成して格納する
					this.array[i] = new Array();
					for (j = 0; j < height; j++) {
						// 0 で埋める
						this.array[i][j] = 0;
					}
				}

			}
			;
			Terrein.prototype =
					{
						init: function (iv1, iv2, iv3, iv4, x, y, size) {
							x = x || 0;
							y = y || 0;
							size = size || this.array.length;
							this.generateHeightmap(x, y, size, iv1, iv2, iv3, iv4);
						},
						render: function (ctx, x, y) {
							for (i = 0; i < this.array.length; i++) {
								var tmp = this.array[i];
								for (j = 0; j < tmp.length; j++) {
									//ctx.fillStyle = "rgb(" + Math.floor(this.array[i][j]) + "," + Math.floor(this.array[i][j]) + "," + Math.floor(this.array[i][j]) + ")";
									//ctx.fillRect(i, j, 1, 1); //四角形を描く



									var r = 0;
									var g = 0;
									var b = 0;

									var startR = 134;
									var startG = 36;
									var startB = 25;
									var endR = 255;
									var endG = 255;
									var endB = 255;
									var startH = 160;
									var endH = 255;
									var incR = 0; //(endR - startR) / (endH - startH);
									var incG = 0; //(endG - startG) / (endH - startH);
									var incB = 0; //(endB - startB) / (endH - startH);

									var nowP = this.array[i][j];// / 16;


									if (nowP < 20 * 16) {


										startR = 0;
										startG = 0;
										startB = 139;
										endR = 0;
										endG = 0;
										endB = 205;
										startH = 0 * 16;
										endH = 19 * 16;
										incR = (endR - startR) / (endH - startH);
										incG = (endG - startG) / (endH - startH);
										incB = (endB - startB) / (endH - startH);



									} else if (20 * 16 <= nowP && nowP < 30 * 16) {
// 30	144	255
// 100	149	237
										startR = 0;
										startG = 0;
										startB = 205;
										endR = 65;
										endG = 105;
										endB = 237;
										startH = 20 * 16;
										endH = 29 * 16;
										incR = (endR - startR) / (endH - startH);
										incG = (endG - startG) / (endH - startH);
										incB = (endB - startB) / (endH - startH);


										/////////////////////// ここまで海 /////////
									} else if (30 * 16 <= nowP && nowP < 160 * 16) {
										startR = 0;
										startG = 101;
										startB = 68;
										endR = 228;
										endG = 204;
										endB = 116;
										startH = 30 * 16;
										endH = 159 * 16;
										incR = (endR - startR) / (endH - startH);
										incG = (endG - startG) / (endH - startH);
										incB = (endB - startB) / (endH - startH);


									} else if (160 * 16 <= nowP && nowP < 255 * 16) {

										// 184	134 11
										startR = 228;
										startG = 204;
										startB = 116;
										endR = 30;
										endG = 30;
										endB = 30;
										startH = 160 * 16;
										endH = 254 * 16;
										incR = (endR - startR) / (endH - startH);
										incG = (endG - startG) / (endH - startH);
										incB = (endB - startB) / (endH - startH);


									} else {
										startR = 184;
										startG = 134;
										startB = 11;
										endR = 255;
										endG = 255;
										endB = 255;
										startH = 255 * 16;
										endH = 255 * 16;
										incR = (endR - startR) / (endH - startH);
										incG = (endG - startG) / (endH - startH);
										incB = (endB - startB) / (endH - startH);


									}

									r = Math.floor(incR * (nowP - startH) + startR);
									g = Math.floor(incG * (nowP - startH) + startG);
									b = Math.floor(incB * (nowP - startH) + startB);

									ctx.fillStyle = "rgba(" + r + "," + g + "," + b + ",1.0)";
									ctx.fillRect(i + x, j, 1, 1); //四角形を描く
								}
							}


							ctx.beginPath();

							ctx.globalCompositeOperation = "lighter";
							ctx.strokeStyle = "rgba(200,200,200,0.5)";
							for (i = 0; i <= this.array.length; i += 64)
							{
								ctx.moveTo(i + x, 0);
								ctx.lineTo(i + x, 1024);
							}

							for (i = 0; i <= this.array.length; i += 64)
							{
								ctx.moveTo(0 + x, i);
								ctx.lineTo(1024 + x, i);
							}
							ctx.globalCompositeOperation = "source-over";


							ctx.stroke();
						},
						// x, y = 左上座標
						// size = 現在のサイズ(幅, 高さ)
						// tl = 左上の値, tr = 右上の値, bl = 左下の値, br = 右下の値
						generateHeightmap: function (x, y, size, tl, tr, bl, br) {
							/*
							 if ( x % 32 === 0){
							 $('#progress').text('x=' + x +',y=' +  y);
							 
							 }					
							 */
							//


							// minSize未満のサイズになったら分割を終了させる
							if (size < 2) {
								// 平均値を出す
								this.array[x][y] = (tl + tr + bl + br) / 4;
								/*
								 if (this.array[x][y] === 0) {
								 this.array[x][y] = (tl + tr + bl + br) / 4;
								 }
								 */
							} else {
								/*
								 
								 if ( this.array[x][y] !== 0 && this.array[x + size - 1 ][y] !== 0) {
								 tl =  this.array[x][y];
								 tr =  this.array[x + size - 1 ][y];
								 bl =  this.array[x][y + size - 1 ];
								 br =  this.array[x + size - 1][y + size - 1];
								 }
								 */

								// 四隅から見て中央にあるピクセルに平均値 + 変位させるランダムな値を入れる
								/*
								 var midPoint = this.array[x + size / 2][y + size / 2];
								 var rndPoint = (tl + tr + bl + br) / 4 + (Math.seededRandom(8192) - 4096) * (size / 512);
								 
								 if (midPoint !== 0) {
								 midPoint = midPoint;// * Math.seededRandom(1.2,0.8);
								 } else {
								 midPoint = rndPoint;
								 }
								 */
								var midPoint = (tl + tr + bl + br) / 4 + (Math.seededRandom(8192) - 4096) * (size / this.iniSize);


								if (midPoint < 0)
									midPoint = 0;
								if (midPoint > 4096)
									midPoint = 4096;


								// 中央から見て上下左右にあるピクセルにも平均値を入れる
								var top = (tl + tr) / 2; // 上 = 左上と右上の平均値
								var bottom = (bl + br) / 2; // 下 = 左下と右下の平均値
								var left = (tl + bl) / 2; // 左 = 左上と左下の平均値
								var right = (tr + br) / 2; // 右 = 右上と右下の平均値
								/*
								 if ( this.array[x + size / 2 - 1][y] !== 0 )        {
								 top = this.array[x + size / 2][y];
								 }
								 if ( this.array[x + size / 2 -1][y + size-1] !== 0 ) {
								 bottom = this.array[x + size / 2-1][y + size -1];
								 }
								 if ( this.array[x][y + size / 2 -1] !== 0 )  {
								 left = this.array[x][y + size / 2 -1];
								 }
								 if ( this.array[x + size - 1][y + size / 2 -1] !== 0 ) {
								 right = this.array[x + size -1][y +  size / 2 -1];
								 }
								 */
								// 2*2に分割するのでサイズ(幅, 高さ)を半分にする
								size /= 2;
								// 左上
								this.generateHeightmap(x, y, size, tl, top, left, midPoint);
								// 右上
								this.generateHeightmap(x + size, y, size, top, tr, midPoint, right);
								// 左下
								this.generateHeightmap(x, y + size, size, left, midPoint, bl, bottom);
								// 右下
								this.generateHeightmap(x + size, y + size, size, midPoint, right, bottom, br);
							}
						}
					};


// in order to work 'Math.seed' must NOT be undefined,
// so in any case, you HAVE to provide a Math.seed
			Math.seededRandom = function (max, min) {
				max = max || 1;
				min = min || 0;

				Math.seed = (Math.seed * 9301 + 49297) % 233280;
				var rnd = Math.seed / 233280;

				return min + rnd * (max - min);
			}

		</script>


	</body>
</html>
